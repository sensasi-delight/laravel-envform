<?php

declare(strict_types=1);

namespace EnvForm\Services;

use Illuminate\Support\Collection;
use Illuminate\Support\Facades\File;
use Symfony\Component\Finder\Finder;

/**
 * @phpstan-type EnvValue bool|int|string|null
 */
class DotEnvService
{
    public function __construct(
        /**
         * HOTFIX: `KeyManager` circular dependency by disabling DEPENDENCY INJECTION
         */
        // private readonly KeyManager $keyManager
    ) {}

    /**
     * Find available .env files in the base path.
     *
     * @return array<string, string>
     */
    public function findFiles(string $basePath): array
    {
        $files = Finder::create()
            ->files()
            ->in($basePath)
            ->name('.env*')
            ->depth(0)
            ->ignoreDotFiles(false);

        $options = [];
        foreach ($files as $file) {
            $options[$file->getFilename()] = $file->getFilename();
        }

        return $options;
    }

    /**
     * Read and parse a .env file into a simple key-value collection.
     *
     * @return Collection<string, string>
     */
    public function read(string $path): Collection
    {
        if (! File::exists($path)) {
            return collect();
        }

        $content = File::get($path);
        $lines = explode("\n", $content);
        $values = collect();

        foreach ($lines as $line) {
            $line = trim($line);
            if (empty($line) || str_starts_with($line, '#')) {
                continue;
            }

            if (str_contains($line, '=')) {
                [$key, $value] = explode('=', $line, 2);
                $values->put(trim($key), trim($value, '"\' '));
            }
        }

        return $values;
    }

    /**
     * Update or create a .env file with given values and metadata.
     *
     * @param  array<string, EnvValue>  $values
     */
    public function write(string $path, array $values): void
    {
        /**
         * @todo WILL use EnvKeyDefinition instead remapping into this array
         *
         * @var array<string, string> $metadata  [ENV_KEY => GroupName]
         */
        $metadata = app(KeyManager::class)->getShouldAskEnvKeys()->pluck('group', 'key')->toArray();

        $existing = $this->read($path)->toArray();

        // 1. Active Values: Everything passed in (which now includes backfilled defaults/currents)
        $activeValues = $values;

        // 2. Deprecated Values: Keys in the existing file that are NO LONGER in the config metadata
        $deprecatedValues = array_diff_key($existing, $metadata);

        $grouped = [];

        // Group Active Keys by their configuration file name
        foreach ($activeValues as $key => $value) {
            $group = $metadata[$key] ?? 'Other / Manually Added';
            $grouped[$group][$key] = $value;
        }

        // Group Deprecated Keys into a 'ZZZ_Deprecated' group to ensure they sort to the bottom
        if (! empty($deprecatedValues)) {
            foreach ($deprecatedValues as $key => $value) {
                $grouped['ZZZ_Deprecated'][$key] = $value;
            }
        }

        ksort($grouped);

        $content = [
            '# Generated by Laravel EnvForm',
            '# Last updated: '.date('Y-m-d H:i:s'),
        ];

        foreach ($grouped as $groupName => $items) {
            $isDeprecated = ($groupName === 'ZZZ_Deprecated');
            $displayName = $isDeprecated ? 'Deprecated / Unused' : $groupName;

            $content[] = '';
            $content[] = "# --- {$displayName} ---";

            foreach ($items as $key => $value) {
                $line = "{$key}=".$this->formatValue($value);
                $content[] = $isDeprecated ? "# {$line}" : $line;
            }
        }

        File::put($path, implode("\n", $content));
    }

    private function formatValue(mixed $value): string
    {
        if (\is_bool($value)) {
            return $value ? 'true' : 'false';
        }

        if (\is_null($value)) {
            return 'null';
        }

        if (\is_array($value)) {
            return 'null';
        }

        $str = (string) $value;

        return preg_match('/\s|[#$]/', $str) ? "\"{$str}\"" : $str;
    }
}
